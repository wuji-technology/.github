name: 'Auto Release from CHANGELOG'
description: 'Ëß£Êûê CHANGELOG.md Âπ∂Ëá™Âä®ÂàõÂª∫ GitHub Release'
author: 'wuji-technology'

inputs:
  changelog-path:
    description: 'CHANGELOG Êñá‰ª∂Ë∑ØÂæÑ'
    required: false
    default: 'CHANGELOG.md'
  github-token:
    description: 'GitHub Token'
    required: true
  draft:
    description: 'ÊòØÂê¶ÂàõÂª∫ËçâÁ®ø Release'
    required: false
    default: 'false'
  prerelease:
    description: 'ÊòØÂê¶Ê†áËÆ∞‰∏∫È¢ÑÂèëÂ∏É'
    required: false
    default: 'false'
  feishu-webhook:
    description: 'È£û‰π¶ webhook URLÔºàÂèØÈÄâÔºåÁî®‰∫éÂèëÈÄÅÂèëÂ∏ÉÈÄöÁü•Ôºâ'
    required: false
    default: ''

outputs:
  version:
    description: 'ÂèëÂ∏ÉÁöÑÁâàÊú¨Âè∑'
    value: ${{ steps.release.outputs.version }}
  release-url:
    description: 'Release È°µÈù¢ URL'
    value: ${{ steps.release.outputs.html_url }}
  body:
    description: 'Ëß£ÊûêÂêéÁöÑ Release Notes ÂÜÖÂÆπ'
    value: ${{ steps.release.outputs.body }}
  tag:
    description: 'Git tag ÂêçÁß∞'
    value: ${{ steps.release.outputs.tag }}

runs:
  using: 'composite'
  steps:
    - name: Parse CHANGELOG and Upsert Release
      id: release
      uses: actions/github-script@v7
      env:
        CHANGELOG_PATH: ${{ inputs.changelog-path }}
        INPUT_DRAFT: ${{ inputs.draft }}
        INPUT_PRERELEASE: ${{ inputs.prerelease }}
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const fs = require('fs');

          const changelogPath = process.env.CHANGELOG_PATH || 'CHANGELOG.md';

          // Ê£ÄÊü• CHANGELOG.md ÊòØÂê¶Â≠òÂú®
          if (!fs.existsSync(changelogPath)) {
            core.setFailed(`${changelogPath} not found`);
            return;
          }
          const changelog = fs.readFileSync(changelogPath, 'utf8')
            .replace(/\r\n?/g, '\n');

          // È™åËØÅËß¶Âèë‰∫ã‰ª∂ÊòØÂê¶‰∏∫ tag push
          if (!context.ref.startsWith('refs/tags/')) {
            core.setFailed(`This action must be triggered by a tag push. Current ref: ${context.ref}`);
            return;
          }

          // ‰ªé tag ÊèêÂèñÁâàÊú¨Âè∑ÔºàÊîØÊåÅÈ¢ÑÂèëÂ∏ÉÁâàÊú¨Â¶Ç 1.0.0-rc4Ôºâ
          const tag = context.ref.replace('refs/tags/', '');

          // È™åËØÅ tag Ê†ºÂºèÂøÖÈ°ª‰ª• v ÂºÄÂ§¥
          if (!tag.startsWith('v')) {
            core.setFailed(`Invalid tag format: "${tag}". Tag must start with "v" (e.g., v1.0.0, v1.0.0-rc1). This is required for consistent Full Changelog links.`);
            return;
          }

          const version = tag.replace(/^v/, '');
          console.log(`Processing tag: ${tag}, version: ${version}`);

          // ÂàÜÁ±ªÊò†Â∞Ñ
          const categoryMap = {
            'Added': 'New Features', 'Êñ∞Â¢û': 'New Features',
            'Changed': 'Improvements', 'ÂèòÊõ¥': 'Improvements',
            'Fixed': 'Bug Fixes', '‰øÆÂ§ç': 'Bug Fixes'
          };
          const cautionCategories = {
            'Removed': 'Removed', 'ÁßªÈô§': 'Removed',
            'Deprecated': 'Deprecated', 'Â∫üÂºÉ': 'Deprecated',
            'Security': 'Security', 'ÂÆâÂÖ®': 'Security'
          };

          // Ëß£ÊûêÁâàÊú¨ÂÜÖÂÆπ
          function parseContent(content) {
            const sections = { 'New Features': [], 'Improvements': [], 'Bug Fixes': [] };
            const cautionItems = [];
            let currentCategory = '';
            let currentCautionPrefix = '';

            for (const line of content.trim().split('\n')) {
              const catMatch = line.match(/^### (.+)/);
              if (catMatch) {
                const cat = catMatch[1].trim();
                if (categoryMap[cat]) {
                  currentCategory = categoryMap[cat];
                  currentCautionPrefix = '';
                } else if (cautionCategories[cat]) {
                  currentCategory = 'CAUTION';
                  currentCautionPrefix = cautionCategories[cat];
                } else {
                  currentCategory = '';
                }
              } else if (line.startsWith('- ')) {
                const item = line.slice(2);
                if (currentCategory === 'CAUTION') {
                  cautionItems.push(`**${currentCautionPrefix}**: ${item}`);
                } else if (currentCategory && sections[currentCategory]) {
                  sections[currentCategory].push(item);
                }
              }
            }

            let body = '';
            for (const section of ['New Features', 'Improvements', 'Bug Fixes']) {
              if (sections[section].length > 0) {
                body += `### ${section}\n${sections[section].map(i => `- ${i}`).join('\n')}\n\n`;
              }
            }
            if (cautionItems.length > 0) {
              body += `> [!CAUTION]\n${cautionItems.map(i => `> - ${i}`).join('\n')}\n\n`;
            }
            return body.trim();
          }

          // ËΩ¨‰πâÁâàÊú¨Âè∑‰∏≠ÁöÑÁâπÊÆäÂ≠óÁ¨¶Áî®‰∫éÊ≠£ÂàôÂåπÈÖç
          const escapedVersion = version.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

          // Êõ¥ÂÅ•Â£ÆÁöÑÁâàÊú¨ÂåπÈÖçÊ≠£ÂàôÔºàÊîØÊåÅÂ§öÁßçÊó•ÊúüÊ†ºÂºèÂíåÂèØÈÄâÂÜÖÂÆπÔºâ
          const versionRegex = new RegExp(`## \\[${escapedVersion}\\](?:[^\\n]*-\\s*(\\d{4}-\\d{2}-\\d{2}))?[^\\n]*\\n([\\s\\S]*?)(?=\\n## \\[|$)`);
          const match = changelog.match(versionRegex);

          if (!match) {
            core.setFailed(`Version ${version} not found in CHANGELOG.md`);
            return;
          }

          const date = match[1] || new Date().toISOString().split('T')[0];
          const content = match[2];
          let body = parseContent(content);

          if (!body) {
            console.log(`Warning: No content parsed for version ${version}`);
          }

          // Ëé∑ÂèñÊâÄÊúâÁâàÊú¨Áî®‰∫é Full ChangelogÔºàÊîØÊåÅÈ¢ÑÂèëÂ∏ÉÁâàÊú¨Ôºâ
          const allVersions = [...changelog.matchAll(/## \[(\d+\.\d+\.\d+(?:-[a-zA-Z0-9.]+)?)\]/g)].map(m => m[1]);
          const versionIndex = allVersions.indexOf(version);
          if (versionIndex === -1) {
            console.log(`Warning: version ${version} not found in version list for Full Changelog`);
          } else {
            const prevVersion = allVersions[versionIndex + 1];
            if (prevVersion) {
              body += `\n\n---\n\n**Full Changelog**: [v${prevVersion}...${tag}](https://github.com/${context.repo.owner}/${context.repo.repo}/compare/v${prevVersion}...${tag})`;
            }
          }

          // Ê£ÄÊü• release ÊòØÂê¶Â∑≤Â≠òÂú®Ôºàupsert Ê®°ÂºèÔºâ
          let releaseId = null;
          try {
            const { data } = await github.rest.repos.getReleaseByTag({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag: tag
            });
            releaseId = data.id;
            console.log(`Found existing release: ${tag} (id: ${releaseId})`);
          } catch (e) {
            if (e.status !== 404) throw e;
            console.log(`No existing release for tag: ${tag}`);
          }

          const releaseBody = `## ${tag} (${date})\n\n${body}`;
          const isDraft = process.env.INPUT_DRAFT === 'true';
          const isPrerelease = process.env.INPUT_PRERELEASE === 'true';

          const releaseData = {
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: tag,
            name: tag,
            body: releaseBody,
            draft: isDraft,
            prerelease: isPrerelease,
            make_latest: 'false'
          };

          let releaseUrl = '';
          if (releaseId) {
            // Êõ¥Êñ∞Áé∞Êúâ release
            const { data } = await github.rest.repos.updateRelease({
              ...releaseData,
              release_id: releaseId
            });
            releaseUrl = data.html_url;
            console.log(`Updated release: ${tag}`);
          } else {
            // ÂàõÂª∫Êñ∞ release
            const { data } = await github.rest.repos.createRelease(releaseData);
            releaseUrl = data.html_url;
            console.log(`Created release: ${tag}`);
          }

          core.setOutput('version', version);
          core.setOutput('html_url', releaseUrl);
          core.setOutput('body', releaseBody);
          core.setOutput('tag', tag);

    - name: Send Feishu notification
      if: ${{ success() && inputs.feishu-webhook != '' }}
      uses: actions/github-script@v7
      env:
        FEISHU_WEBHOOK: ${{ inputs.feishu-webhook }}
        RELEASE_VERSION: ${{ steps.release.outputs.version }}
        RELEASE_URL: ${{ steps.release.outputs.html_url }}
        RELEASE_TAG: ${{ steps.release.outputs.tag }}
        RELEASE_BODY: ${{ steps.release.outputs.body }}
      with:
        script: |
          const webhookUrl = process.env.FEISHU_WEBHOOK;
          const version = process.env.RELEASE_VERSION;
          const releaseUrl = process.env.RELEASE_URL;
          const tag = process.env.RELEASE_TAG;
          const releaseBody = process.env.RELEASE_BODY || '';
          const repo = context.repo.repo;

          if (!webhookUrl) {
            console.log('Feishu webhook not configured, skipping notification');
            return;
          }

          // Extract release notes (remove header and Full Changelog link)
          let releaseNotes = releaseBody
            .replace(/^## v[\d.]+ \(\d{4}-\d{2}-\d{2}\)\s*\n\n?/, '')  // Remove version header
            .replace(/\n---\n\n\*\*Full Changelog\*\*:.*$/, '')        // Remove Full Changelog
            .trim();

          // Convert markdown headers for Feishu
          releaseNotes = releaseNotes
            .replace(/^### /gm, '**')
            .replace(/^(\*\*[^*]+)\n/gm, '$1**\n');

          const elements = [
            {
              tag: 'div',
              text: {
                content: `**Repository**: ${repo}\n**Version**: ${tag}`,
                tag: 'lark_md'
              }
            }
          ];

          // Add release notes if available
          if (releaseNotes) {
            elements.push({
              tag: 'hr'
            });
            elements.push({
              tag: 'div',
              text: {
                content: releaseNotes,
                tag: 'lark_md'
              }
            });
          }

          // Add action button
          elements.push({
            tag: 'action',
            actions: [{
              tag: 'button',
              text: { content: 'View Release', tag: 'plain_text' },
              url: releaseUrl,
              type: 'primary'
            }]
          });

          const card = {
            msg_type: 'interactive',
            card: {
              header: {
                title: { content: `üöÄ ${repo} ${tag} Released`, tag: 'plain_text' },
                template: 'green'
              },
              elements: elements
            }
          };

          try {
            const response = await fetch(webhookUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(card)
            });

            if (response.ok) {
              console.log('‚úÖ Feishu notification sent successfully');
            } else {
              console.log(`‚ö†Ô∏è Feishu notification failed: ${response.status}`);
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è Feishu notification error: ${error.message}`);
          }
